//
// Created by edz on 2022/4/13.
//

#include "class/jclass_file.h"
#include "object/jmethod.h"
#include "io/input_stream.h"
#include "engine/jnilib.h"

#include "javah.h"

#include <cstdio>

using namespace javsvm;

int context_t::open(const char *input) noexcept
{
    file_input fin(input);
    fin.big_endian();

    if (! fin.ok()) {
        PLOGE("failed to open file '%s'\n", input);
        return 1;
    }

    jclass_file &j_file = class_file;
    if (j_file.read_from(fin) != 0) {
        return 2;
    }

    // 获取类名
    {
        auto class_info = j_file.constant_pool.cast<jclass_const_class>(j_file.this_class);
        auto utf8 = j_file.constant_pool.cast<jclass_const_utf8>(class_info->index);
        class_name = (char *) utf8->bytes;
    }

    // 寻找 native 函数
    methods.clear();

    for (int i = 0; i < j_file.method_count; i ++) {
        auto &method = j_file.methods[i];
        if ((method.access_flag & jclass_method::ACC_NATIVE) == 0) {
            continue;
        }
        auto *name = (char*) j_file.constant_pool.cast<jclass_const_utf8>(method.name_index)->bytes;
        auto *sig = (char*) j_file.constant_pool.cast<jclass_const_utf8>(method.descriptor_index)->bytes;

        jmethod m = {
                .orig = &method,
                .name = name,
                .sig = sig,
                .access_flag = method.access_flag
        };

        std::string k = name;
        const auto &it = methods.find(k);
        if (it == methods.end()) {
            auto &list = methods[k] = std::list<jmethod>();
            list.push_back(m);
        }
        else {
            it->second.push_back(m);
        }
    }

    return 0;
}

void context_t::print_as_list(FILE *fout) const noexcept
{
    for (const auto &entry : methods) {
        for (const auto &it: entry.second) {
            // 生成的函数名。如果该函数有重载，使用长名称，否则使用短名称
            const std::string &name = entry.second.size() == 1 ?
                                      jni_short_name(class_name, it.name) :
                                      jni_long_name(class_name, it.name, it.sig);
            fprintf(fout, "%s %s %s\n", it.name, it.sig, name.c_str());
        }
    }
}

static const char* next_token(const char **pstr) noexcept
{
    const char *str = *pstr;
    const char *token = "";

    switch (str[0]) {
        case 'V': token = "void";       break;
        case 'Z': token = "jboolean";   break;
        case 'B': token = "jbyte";      break;
        case 'C': token = "jchar";      break;
        case 'S': token = "jshort";     break;
        case 'I': token = "jint";       break;
        case 'J': token = "jlong";      break;
        case 'F': token = "jfloat";     break;
        case 'D': token =  "jdouble";   break;
        case 'L': {
            constexpr const char *java_lang_String = "Ljava/lang/String;";
            constexpr const char *java_lang_Class = "Ljava/lang/Class;";

            if (strncmp(str, java_lang_String, strlen(java_lang_String)) == 0) {
                token = "jstring";
            }
            else if (strncmp(str, java_lang_Class, strlen(java_lang_Class)) == 0) {
                token = "jclass";
            }
            else {
                token = "jobject";
            }
            while (*str != ';') str ++;
            break;
        }
        case '[': {
            str ++;
            switch (*str) {
                case 'Z': token = "jbooleanArray";  break;
                case 'B': token = "jbyteArray";     break;
                case 'C': token = "jcharArray";     break;
                case 'S': token = "jshortArray";    break;
                case 'I': token = "jintArray";      break;
                case 'J': token = "jlongArray";     break;
                case 'F': token = "jfloatArray";    break;
                case 'D': token = "jdoubleArray";   break;
                case 'L':
                case '[': {
                    token = "jobjectArray";
                    while (*str == '[') str ++;
                    if (*str == 'L') while (*str != ';') str ++;
                    break;
                }
            }
            break;
        }
        default:
            LOGE("unknown token: '%c'(%#02x)\n", str[0], str[0]);
            break;
    }
    // 指向下一个字符
    *pstr = str + 1;
    return token;
}


void context_t::print_as_h(FILE *fout) const noexcept
{
    std::string def;
    def += "JAVA_";
    def += class_name;
    def += "_H";
    for (auto &ch : def) {
        if (ch >= 'a' && ch <= 'z') {
            ch = (char) (ch - 'a' + 'A');
        }
        else if (ch == '/') {
            ch = '_';
        }
    }

    fprintf(fout, "/**\n"
                  " * auto generated by javsvm-javah, don't modify it.\n"
                  " */\n\n"
                  "#ifndef %s\n"
                  "#define %s\n\n"
                  "#include <jni.h>\n\n"
                  "#ifdef __cplusplus\n"
                  "extern \"C\" {\n"
                  "#endif\n\n",
            def.c_str(), def.c_str());

    std::string params_list;

    for (const auto &entry : methods) {
        for (const auto &method : entry.second) {
            // 写入注释
            fprintf(fout, "/**\n"
                          " * class: %s\n"
                          " * method: %s\n"
                          " * sig: %s\n"
                          " */\n",
                          class_name, method.name, method.sig);
            // 生成的函数名。如果该函数有重载，使用长名称，否则使用短名称
            const std::string &name = entry.second.size() == 1 ?
                                      jni_short_name(class_name, method.name) :
                                      jni_long_name(class_name, method.name, method.sig);

            // 通用参数列表
            params_list.clear();
            params_list += "JNIEnv *env, ";
            params_list += (method.access_flag & jclass_method::ACC_STATIC) == 0 ?
                           "jobject self, " :
                           "jclass klass, ";

            // 函数参数列表
            const char *sig = method.sig + 1;
            while (sig[0] != ')') {
                auto token = next_token(&sig);
                params_list += token;
                params_list += ", ";
            }

            // 去除末尾的 ", "
            params_list.resize(params_list.length() - 2);

            // 获取返回值
            sig ++;
            const char *return_type = next_token(&sig);

            // 写入
            fprintf(fout, "JNIEXPORT %s JNICALL\n"
                          "%s\n"
                          "    (%s);\n\n",
                    return_type, name.c_str(), params_list.c_str());
        }
    }

    fprintf(fout, "\n\n"
                  "#ifdef __cplusplus\n"
                  "}\n"
                  "#endif\n"
                  "#endif // %s\n\n",
            def.c_str());
}

void context_t::print_as_cpp(FILE *fout) const noexcept
{
    fprintf(fout, "\n#include <jni.h>\n\n");

    std::string params_list;

    for (const auto &entry : methods) {
        for (const auto &method : entry.second) {
            // 写入注释
            fprintf(fout, "/**\n"
                          " * class: %s\n"
                          " * method: %s\n"
                          " * sig: %s\n"
                          " */\n",
                    class_name, method.name, method.sig);
            // 生成的函数名。如果该函数有重载，使用长名称，否则使用短名称
            const std::string &name = entry.second.size() == 1 ?
                                      jni_short_name(class_name, method.name) :
                                      jni_long_name(class_name, method.name, method.sig);

            // 通用参数列表
            params_list.clear();
            params_list += "JNIEnv *env, ";
            params_list += (method.access_flag & jclass_method::ACC_STATIC) == 0 ?
                           "jobject self, " :
                           "jclass klass, ";

            // 函数参数列表
            const char *sig = method.sig + 1;
            while (sig[0] != ')') {
                auto token = next_token(&sig);
                params_list += token;
                params_list += ", ";
            }

            // 去除末尾的 ", "
            params_list.resize(params_list.length() - 2);

            // 获取返回值
            sig ++;
            const char *return_type = next_token(&sig);

            // 写入
            fprintf(fout, "extern \"C\" JNIEXPORT %s JNICALL\n"
                          "%s\n"
                          "    (%s)\n"
                          "{\n\n"
                          "}\n\n",
                    return_type, name.c_str(), params_list.c_str());
        }
    }
}