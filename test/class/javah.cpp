//
// Created by edz on 2022/4/6.
//

#include "utils/log.h"
#include "class/jclass_file.h"
#include "io/input_stream.h"
#include "object/jmethod.h"
#include "engine/jnilib.h"

#include <map>
#include <list>

using namespace javsvm;

static std::string get_output_path(const char *in) noexcept
{
    std::string s(in);

    if (s.find_last_of(".class") == s.length() - 1) {
        s.resize(s.length() - strlen(".class"));
        s += ".h";
    }

    return s;
}

static const char* next_token(const char **pstr) noexcept
{
    const char *str = *pstr;
    const char *token = "";

    switch (str[0]) {
        case 'V': token = "void";       break;
        case 'Z': token = "jboolean";   break;
        case 'B': token = "jbyte";      break;
        case 'C': token = "jchar";      break;
        case 'S': token = "jshort";     break;
        case 'I': token = "jint";       break;
        case 'J': token = "jlong";      break;
        case 'F': token = "jfloat";     break;
        case 'D': token =  "jdouble";   break;
        case 'L': {
            constexpr const char *java_lang_String = "Ljava/lang/String;";
            constexpr const char *java_lang_Class = "Ljava/lang/Class;";

            if (strncmp(str, java_lang_String, strlen(java_lang_String)) == 0) {
                token = "jstring";
            }
            else if (strncmp(str, java_lang_Class, strlen(java_lang_Class)) == 0) {
                token = "jclass";
            }
            else {
                token = "jobject";
            }
            while (*str != ';') str ++;
            break;
        }
        case '[': {
            str ++;
            switch (*str) {
                case 'Z': token = "jbooleanArray";  break;
                case 'B': token = "jbyteArray";     break;
                case 'C': token = "jcharArray";     break;
                case 'S': token = "jshortArray";    break;
                case 'I': token = "jintArray";      break;
                case 'J': token = "jlongArray";     break;
                case 'F': token = "jfloatArray";    break;
                case 'D': token = "jdoubleArray";   break;
                case 'L':
                case '[': {
                    token = "jobjectArray";
                    while (*str == '[') str ++;
                    if (*str == 'L') while (*str != ';') str ++;
                    break;
                }
            }
            break;
        }
        default:
            LOGE("unknown token: '%c'(%#02x)\n", str[0], str[0]);
            break;
    }
    // 指向下一个字符
    *pstr = str + 1;
    return token;
}


struct context_t
{
    const char *class_name = "";
    std::map<std::string, std::list<jmethod>> methods;
};

static void write_to_file(const context_t &context, FILE *fout) noexcept
{
    std::string def = "JAVA_";
    def += context.class_name;
    def += "_H";
    for (auto &ch : def) {
        if (ch >= 'a' && ch <= 'z') {
            ch = (char) (ch - 'a' + 'A');
        }
        else if (ch == '/') {
            ch = '_';
        }
    }

    fprintf(fout, "/**\n"
                  " * auto generated by javsvm-javah, don't modify it.\n"
                  " */\n\n"
                  "#ifndef %s\n"
                  "#define %s\n\n"
                  "#include <jni.h>\n\n"
                  "#ifdef __cplusplus\n"
                  "extern \"C\" {\n"
                  "#endif\n\n",
                  def.c_str(), def.c_str());

    std::string params_list;

    for (const auto &entry : context.methods) {
        for (const auto &method : entry.second) {
            // 写入注释
            fprintf(fout, "/**\n"
                          " * class: %s\n"
                          " * method: %s\n"
                          " * sig: %s\n"
                          " */\n",
                          context.class_name, method.name, method.sig);
            // 生成的函数名。如果该函数有重载，使用长名称，否则使用短名称
            const std::string &name = entry.second.size() == 1 ?
                        jni_short_name(context.class_name, method.name) :
                        jni_long_name(context.class_name, method.name, method.sig);

            // 通用参数列表
            params_list.clear();
            params_list += "JNIEnv *env, ";
            params_list += (method.access_flag & jclass_method::ACC_STATIC) == 0 ?
                    "jobject self, " :
                    "jclass klass, ";

            // 函数参数列表
            const char *sig = method.sig + 1;
            while (sig[0] != ')') {
                auto token = next_token(&sig);
                params_list += token;
                params_list += ", ";
            }

            // 去除末尾的 ", "
            params_list.resize(params_list.length() - 2);

            // 获取返回值
            sig ++;
            const char *return_type = next_token(&sig);

            // 写入
            fprintf(fout, "JNIEXPORT %s JNICALL\n"
                          "%s\n"
                          "(%s);\n\n",
                          return_type, name.c_str(), params_list.c_str());
        }
    }

    fprintf(fout, "\n\n"
                  "#ifdef __cplusplus\n"
                  "}\n"
                  "#endif\n"
                  "#endif // %s\n\n",
                  def.c_str());
}

static int parse(const char *in) noexcept
{
    file_input fin(in);
    fin.big_endian();

    if (! fin.ok()) {
        PLOGE("failed to open file '%s'\n", in);
        return 1;
    }

    jclass_file j_file;
    if (j_file.read_from(fin) != 0) {
        return 2;
    }

    context_t context;
    {
        auto class_info = j_file.constant_pool.cast<jclass_const_class>(j_file.this_class);
        auto utf8 = j_file.constant_pool.cast<jclass_const_utf8>(class_info->index);
        context.class_name = (char *) utf8->bytes;
    }

    // 寻找 native 函数
    for (int i = 0; i < j_file.method_count; i ++) {
        auto &method = j_file.methods[i];
        if ((method.access_flag & jclass_method::ACC_NATIVE) == 0) {
            continue;
        }
        auto *name = (char*) j_file.constant_pool.cast<jclass_const_utf8>(method.name_index)->bytes;
        auto *sig = (char*) j_file.constant_pool.cast<jclass_const_utf8>(method.descriptor_index)->bytes;

        jmethod m = {
                .orig = &method,
                .name = name,
                .sig = sig,
                .access_flag = method.access_flag
        };

        std::string k = name;
        const auto &it = context.methods.find(k);
        if (it == context.methods.end()) {
            auto &list = context.methods[k] = std::list<jmethod>();
            list.push_back(m);
        }
        else {
            it->second.push_back(m);
        }
    }

    auto output_path = get_output_path(in);
    FILE *fout = fopen(output_path.c_str(), "wb");
    if (fout == nullptr) {
        PLOGE("failed to open output file '%s'\n", output_path.c_str());
        return 3;
    }

    write_to_file(context, fout);

    fclose(fout);
    return 0;
}


int main(int argc, const char *argv[])
{
    if (argc < 2) {
        LOGE("usage: %s <input_file> ...\n", argv[0]);
        return 1;
    }
    for (int i = 1; i < argc; ++i) {
        parse(argv[i]);
    }

    return 0;
}